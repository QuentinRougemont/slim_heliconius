// Keywords: migration, dispersal, fitness()
//assumption for genomics:
//mutation rate from Keightley et al: µ= 2.9 × 10−9
//assumed inital r = 1e-08 and rescaled using 1/2*(1-(1-2r)^n)
//assumed Nc = 1e6
//rescale all by a factor of 100
//Size of supergene ~1.5mb on ~300mb so we rescale to a 5kb locus on a 1mb block 

initialize() {
	defineGlobal("MU", 2.9e-7);
	defineGlobal("L", 1e5);  //will be set to 1e7 later
	defineGlobal("R", 9.99999e-07);
	initializeMutationRate(MU);
	initializeMutationType("m1", 0.5, "f", 0.0);
	initializeMutationType("m2", 1.0, "f", 0.5);  // introduced mutation
	initializeMutationType("m3", 1.0, "f", 0.5);  // introduced mutation
	initializeMutationType("m4", 1.0, "f", 0.5);  // introduced mutation
	initializeMutationType("m5", 1.0, "f", 0.5);  // introduced mutation
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, L-1);
	initializeRecombinationRate(R);
}
1 {
	//sim.setValue("FST", 0.0);

	subpopCount = 5; 
	for (i in 1:subpopCount)
	sim.addSubpop(i, 500);
	for (i in 2:subpopCount)
	sim.subpopulations[i-1].setMigrationRates(i-1, 0.01);
	for (i in 1:(subpopCount-1))
	sim.subpopulations[i-1].setMigrationRates(i+1, 0.01);


}
1000 late() {
	target = sample(p1.genomes, 200);
	target.addNewDrawnMutation(m2, 10000);
	target = sample(p2.genomes, 200);
	target.addNewDrawnMutation(m3, 10500); //if alls mutation are at the same position. //are they overwrite? //should they occur at different places??
	target = sample(p3.genomes, 200);
	target.addNewDrawnMutation(m4, 10100);
	target = sample(p4.genomes, 200);
	target.addNewDrawnMutation(m5, 10050);

}
fitness(m2, p2) { return 0.2; }
fitness(m3, p3) { return 0.2; }
fitness(m4, p4) { return 0.2; }
fitness(m5, p5) { return 0.2; }

2000: early() {
	// tag all individuals with their m2 mutation count
	inds = sim.subpopulations.individuals;
	inds.tag = inds.countOfMutationsOfType(m2);
	inds.tag = inds.countOfMutationsOfType(m3); //does this overwrite the previous count???
	inds.tag = inds.countOfMutationsOfType(m4); //this is probably not the correct way to go. tag should be reset to zero after the end of each operation
	inds.tag = inds.countOfMutationsOfType(m5); // needs validations to make sure all mut are counted

	// precalculate the mating weights vectors
	for (subpop in c(p1,p2,p3,p4,p5))
	{
		has_m2 = (subpop.individuals.tag > 0);
		subpop.setValue("weights1", ifelse(has_m2, 2.0, 1.0));
		subpop.setValue("weights2", ifelse(has_m2, 0.5, 1.0));
		
		has_m3 = (subpop.individuals.tag > 0);
		subpop.setValue("weights13", ifelse(has_m3, 2.0, 1.0));
		subpop.setValue("weights23", ifelse(has_m3, 0.5, 1.0));

		has_m4 = (subpop.individuals.tag > 0);
		subpop.setValue("weights14", ifelse(has_m4, 2.0, 1.0));
		subpop.setValue("weights24", ifelse(has_m4, 0.5, 1.0));

		has_m5 = (subpop.individuals.tag > 0);
		subpop.setValue("weights15", ifelse(has_m5, 2.0, 1.0));
		subpop.setValue("weights25", ifelse(has_m5, 0.5, 1.0));	
	}
}
2000: mateChoice() {
	if (individual.tag > 0)
		return weights * sourceSubpop.getValue("weights1");
	else
		return weights * sourceSubpop.getValue("weights2");

}

//10000: late() {
//4000: late() {
	//FST = calcFST(p1.genomes, p2.genomes);
	//sim.setValue("FST", sim.getValue("FST") + FST);
//}
//19999 late() {
18999 late() {
	//cat("Mean FST at equilibrium: " + (sim.getValue("FST") / 10000) + "\n" );
	het = calcHeterozygosity(p1.genomes);
	pi2 = calcHeterozygosity(p2.genomes);
	pi3 = calcHeterozygosity(p3.genomes);
	pi4 = calcHeterozygosity(p4.genomes);
	pi5 = calcHeterozygosity(p5.genomes);

	cat("pi1 :" +  het + "\n" );
	cat("pi2 :" +  pi2 + "\n" );
	cat("pi3 :" +  pi3 + "\n" );
	cat("pi4 :" +  pi4 + "\n" );
	cat("pi5 :" +  pi5 + "\n" );

	sim.simulationFinished();
}
